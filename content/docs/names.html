<!-- https://github.com/whosonfirst/whosonfirst-names/blob/master/README.md -->
<h1 id="whosonfirst-names">whosonfirst-names</h1> <p>What things are called in Who's On First</p> <h2 id="names-and-aliases-and-languages--aka-rfc-5646">Names and aliases (and languages) – aka RFC 5646</h2> <p>Who's On First uses a variation of <a href="http://www.rfc-editor.org/rfc/rfc5646.txt">RFC 5646</a> for identifying names. The W3C's <a href="https://www.w3.org/International/articles/language-tags/">Language tags in HTML and XML</a> page describes RFC 5646 like this:</p> <blockquote> <p>RFC 5646 caters for more types of subtag, and allows you to combine them in various ways. While this may appear to make life much more complicated, generally speaking choosing language tags will continue to be a simple matter - however, where you need additional power it will be available to you. In fact, for most people, RFC 5646 should actually make life simpler in a number of ways – for one thing, there is only one place you need to look now for valid subtags.</p> </blockquote> <blockquote> <p>Although it provides some additional options for identifying common language variations, RFC 5646 includes all of the tags that were previously valid. If you have been using RFC 1766, RFC 3066, or RFC 4646 you do not need to make any changes to your tags.</p> </blockquote> <blockquote> <p>The list below shows the various types of subtag that are available. We will work our way through these and how they are used in the sections that follow.</p> </blockquote> <blockquote> <p>language-extlang-script-region-variant-extension-privateuse</p> </blockquote> <h3 id="rfc-5646-bcp-47-comformance">RFC 5646 (BCP 47) comformance</h3> <p><em>Sometimes RFC 5646 is referred to as BCP (Best Current Practice) 47.</em></p> <ul> <li> <p>We follow the same structure outlined in RFC 5646 but use <code>_</code> (underbar) characters instead of <code>-</code> (dash) characters for delimiting individual properties of a language identifier.</p> </li> <li> <p>We use three-letter language codes (rather than two-letter codes) to identify the primary language.</p> </li> <li> <p>The use of either the "script" or "region" subtags is allowed, although neither is required.</p> </li> <li> <p>While not explicitly forbidden neither the "extlang" or the "variant" subtags are commonly used, and Who's On First tools for parsing name labels may not support them.</p> </li> <li> <p>We use private extensions, specifically a <code>-x-[NAME_TYPE]</code> label.</p> </li> </ul> <h3 id="rfc-5646-bcp-47-tag-conversion">RFC 5646 (BCP 47) tag conversion</h3> <ol> <li>Replace the "_" separators with "-"</li> <li>You probably want to replace 3-letter language codes with 2-letter language codes</li> </ol> <h4 id="for-example">For example</h4> <pre><code>eng_x_preferred → en-x-preferred fre_ca_x_variant → fr-ca-x-variant </code></pre> <h3 id="code-y-bits-and-backwards-compatibility">Code-y bits (and backwards compatibility)</h3> <p>The <a href="https://github.com/whosonfirst/py-mapzen-whosonfirst-names">mapzen.whosonfirst.names</a> Python library provides libraries and functions for converting between <code>Who's on First</code>, <code>Geoplanet</code> and <code>RFC 5646 subtags</code>.</p> <p><em>Note: When converting to subtags the library does convert three-letter language codes to two-letter language codes.</em></p> <p>For example:</p> <pre><code>import mapzen.whosonfirst.names  lbl = mapzen.whosonfirst.names.labels() names = ("fin_p", "eng_s", "unk_v")  for n in names: 	print n          n2 = lbl.convert(n, 'geoplanet', 'wof')         print n2          n3 = lbl.convert(n2, 'wof', 'subtags')         print n3          n4 = lbl.convert(n3, 'subtags', 'wof')         print n4          n5 = lbl.convert(n4, 'wof', 'geoplanet')         print n5 </code></pre> <p>Would yield:</p> <pre><code>fin_p fin_x_prefered fin-x-prefered fin_x_prefered fin_p eng_s eng_x_colloquial eng-x-colloquial eng_x_colloquial eng_s unk_v und_x_variant und-x-variant und_x_variant unk_v </code></pre> <h2 id="a-short-history">A short history</h2> <p>In the beginning:</p> <ul> <li> <p>We had names according to QuattroShapes</p> </li> <li> <p>We re-indexed all the names, aliases and translations from WOE (7.10) and concordances between WOE and the Gazetteer for many of them. Those we don't have concordances for will simply be imported in to the Gazetteer as new records complete with their names and aliases.</p> </li> <li> <p>We had concordances for many places in Geonames which also has many of its own aliases and translations, sometimes exceeding those of WOE</p> </li> </ul> <p>WOE defines two properties for a name:</p> <ol> <li>a <a href="https://en.wikipedia.org/wiki/ISO_639-3">ISO 639-3</a> language code</li> <li>a name "type", which is a canned list as defined by the WOE folks:</li> </ol> <pre><code>The Name_Type field is a single letter code that describes the alias as follows:    * P is a preferred English name   * Q is a preferred name (in other languages)   * V is a well-known (but unofficial) variant for the place       (e.g. "New York City" for New York)   * S is either a synonym or a colloquial name for the place       (e.g. "Big Apple" for New York), or a version of the name which       is stripped of accent characters.   * A is an abbreviation or code for the place (e.g. "NYC" for New       York) </code></pre> <p>WOE also distinguishes between a <code>name</code> and an <code>alias</code> so in their world you end up with something like:</p> <pre><code>Name:  Montréal  Language: FRE Alias (ENG_P): Montreal Alias (KOR_Q): 몬트리올 </code></pre> <p>WOE does not however account for the fact that <a href="https://www.youtube.com/watch?v=OHzMTSK1V4o">some countries</a> have multiple languages.</p> <p>With all that in mind, decided that:</p> <ul> <li>We should support multiple languages for a place and label placement</li> <li>We should just use <code>p</code> for a preferred name, regardless of language</li> <li>We should use a <code>name</code> namespace for names because it is explicit (likewise for <code>fullname</code>)</li> <li><code>wof:name</code> is English by default and is a string (rather than a list of strings) that can be used for labels</li> </ul> <p>For example:</p> <pre><code>{ 	"wof:name": "Montreal", 	"wof:lang": [ "eng", "fre" ], 	"name:eng_p": "Montreal", 	"name:eng_a": "YMQ", 	"name:fre_p": "Montréal", 	"name:kor_p": "몬트리올", } </code></pre> <p>But wait, there's more!</p> <p>One day we met <a href="https://github.com/nyampire">@nyampire</a> who told us that he had <a href="https://github.com/nyampire/Gazetteer_JP_2007">a gazetteer of places published by the Japanese government</a> that contained place names in Kanji, Kana and English. Since Kanji is a script the solution described above doesn't work. So now we're using RFC 5646 and subtags.</p> <h2 id="see-also">See also</h2> <ul> <li><a href="https://github.com/whosonfirst/whosonfirst-docs">https://github.com/whosonfirst/whosonfirst-docs</a></li> </ul> 
